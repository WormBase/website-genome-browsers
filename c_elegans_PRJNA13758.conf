[GENERAL]
description = C. elegans (current release)
database    = c_elegans

# where to link to when user clicks in detailed view
link             = /get?name=$name;class=$class
initial landmark = III:9060076..9071672

default tracks = PRIMARY_GENE_TRACK CLASSICAL_ALLELES POLYMORPHISMS LOCI:overview

# examples to show in the introduction
examples = IV 
	   IV:20,000..30,000 
	   lin-29
	   dpy-*
           rhodopsin
	   B0019 
	   PCR_product:sjj_B0019.1
           ttattaaacaatttaa

# Override the [DETAIL SELECT MENU] from detail_select_menu.conf
# C. elegans has a custom detail select menu.
#include includes/detail_menu-c_elegans.conf

# Plugin configuration
#include includes/plugin.conf

[MotifFinder:plugin]
matrix = matrices.txt

[Aligner:plugin]
alignable_tracks   = ESTB ESTO mRNAB
upcase_tracks      = CDS tRNA NG
align_default      = ESTB
upcase_default     = CDS
#ragged_default     = 10

[OligoFinder:plugin]
search_segments = I II III IV V X


# what to show in the overview section
[LOCI:overview]
feature       = gene:landmark
label         = sub {
		my $f = shift;
		return join(", ", $f->get_tag_values('Locus'));
	}
glyph         = generic
bgcolor       = lavender
key           = Landmarks
height        = 5

###################################
# Global track defaults.
# Can be overridden by any track
###################################
[TRACK DEFAULTS]
#include includes/track_defaults.conf

#################################
# database definitions
#################################
[c_elegans:database]
db_adaptor  = Bio::DB::SeqFeature::Store
db_args     = -adaptor DBI::mysql
              -dsn dbi:mysql:database=c_elegans_PRJNA13758_WS240;host=mysql.wormbase.org
	      -user wormbase
	      -pass sea3l3ganz
search options = default, +wildcard, -stem, +fulltext, +autocomplete

# Aggregator format: 
# name{method,method,method/method of parent feature}
# Then to aggregate these in a track:
# aggregator_name:Source
# NOTE: aggregators are processed in the order in which they appear, so
# we would like the full transcript to take precedence over RNAs.
# wormbase_cds: history gene models
# coding: [CDS]
#aggregators = pseudo{exon:Pseudogene,intron:Pseudogene/Pseudogene}
#	      non_coding_transcript_isoform{exon/nc_primary_transcript}
#	      non_coding_transcript{exon/ncRNA_primary_transcript}
#    	      transposon_cds{coding_exon,intron/transposable_element}
#    	      transposon_pseudogene{exon,intron/transposable_element}
#              clone 
#     	      alignment
#	      full_transcript{coding_exon,five_prime_UTR,three_prime_UTR/Transcript}
#	      RNA{exon/Transcript}
#	      curated_gene{coding_exon/CDS}	      
#    	      ngasp_gene{CDS,three_prime_UTR,five_prime_UTR/Transcript}
#	      processed_transcript{coding_exon,five_prime_UTR,three_prime_UTR/CDS}
#	      coding{coding_exon}
#    	      motif_span{motif_segment/Motif}
#    	      rnai{RNAi_reagent}
#	      ost{expressed_sequence_match}
#	      sage_tag{SAGE_tag}
#	      wormbase_cds{coding_exon,CDS,five_prime_UTR,three_prime_UTR/CDS}
#	      trna_transcript{exon/Transcript}
#	      trna_transcript{exon/tRNA} # or the other? which is it?

#[modencode_henikoff:database]
#db_adaptor    = Bio::DB::SeqFeature::Store
#db_args       = -dsn dbi:mysql:database=modencode_henikoff;host=mysql.wormbase.org
#	        -user wormbase
#	        -pass sea3l3ganz
#search options = default +wildcard -stem +fulltext +autocomplete

#[modencode_hillier_genelets:database]
#db_adaptor    = Bio::DB::SeqFeature::Store
#db_args       = -dsn dbi:mysql:database=modencode_hillier_genelets;host=mysql.wormbase.org
#	        -user wormbase
#	        -pass sea3l3ganz
##search options = exact
#search options = default +wildcard -stem +fulltext +autocomplete

#[modencode_hillier_itranscripts:database]
#db_adaptor    = Bio::DB::SeqFeature::Store
#db_args       = -dsn dbi:mysql:database=modencode_hillier_itranscripts;host=mysql.wormbase.org
#	        -user wormbase
#	        -pass sea3l3ganz
#search options = exact

#[modencode_lieb:database]
#db_adaptor    = Bio::DB::SeqFeature::Store
#db_args       = -dsn dbi:mysql:database=modencode_lieb;host=mysql.wormbase.org
#	        -user wormbase
#	        -pass sea3l3ganz
#search options = exact

#[modencode_piano:database]
#db_adaptor    = Bio::DB::SeqFeature::Store
#db_args       = -dsn dbi:mysql:database=modencode_piano;host=mysql.wormbase.org
#	        -user wormbase
#	        -pass sea3l3ganz
#search options = exact

#[modencode_snyder:database]
#db_adaptor    = Bio::DB::SeqFeature::Store
#db_args       = -dsn dbi:mysql:database=modencode_snyder;host=mysql.wormbase.org
#	        -user wormbase
#	        -pass sea3l3ganz
#search options = exact

#[modencode_waterston:database]
#db_adaptor    = Bio::DB::SeqFeature::Store
#db_args       = -dsn dbi:mysql:database=modencode_waterston;host=mysql.wormbase.org
#	        -user wormbase
#	        -pass sea3l3ganz
#search options = exact

# GBrowse Cliff notes:
# title - shown on hover
# label - shown ABOVE feature
# description - shown BELOW feature; can NOT reside in an include file
# Things like bgcolor:
#       bgcolor is applied per COMPONENT, not in aggregate.


################################################
#
# Category: Genes
#
################################################
# [PRIMARY_GENE_TRACK]
# Examples: 
#     miRNA: WBGene00003278 / mir-50   - needs preMRNA handling
#     ncRNA: F02A9.9          - needs nc_primary_transcript handling
#     rRNA:
#     scRNA:
#     snRNA:
#     snoRNA:
#     tRNA:
#     pre_miRNA
#     pseuodgene : WBGene00023295
#include includes/primary_genes.track

# [CODING_TRANSCRIPTS]
#include includes/coding_transcripts.track

# [DNA]
#include includes/dna.track

# [CDS]
#include includes/cds.track

# [HISTORICAL_GENES]
#include includes/historical_genes.track


# This track shows the approximate physical span of genetic intervals
# Examples:
# interpolated_pmap_position: 
# absolute_pmap_position : rcor-1
[GENETIC_LIMITS]
key           = Genetic limits
category      = Genes
feature       = gene:interpolated_pmap_position
		gene:absolute_pmap_position
glyph         = sub {
                    my $f = shift;
                    return ($f->source eq 'interpolated_pmap_position') ? 'span' : 'box';
       }
fgcolor       = black
bgcolor       = sub { my $f = shift;
		      return ($f->source eq 'interpolated_pmap_position') ? 'red' : 'turquoise';
	}
link          = sub { my $f   = shift;
                      my $name = $f->name;
   	              return "/get?name=$name;class=Gene";
	}
height        = 3
label         = sub { my $f = shift;
	      	      my ($status) = $f->attributes('status');
		      my ($gmap)   = $f->attributes('gmap');
		      return "$gmap ($status)";
	}
description   = sub { my $f = shift;
	              my $position = join(' ',$f->notes);
		      return $position;
        }
citation      = This track shows the maximal extents for genetic loci.  
		Loci that have been interpolated onto the physical
                map (and whose precise location is unknown) are shown 
                as a thin black span.  The physical extent of such loci are determined 
                by interpolating their genetic position onto the physical 
                map using 95% confidence limits.  Please note that the actual 
                location of such loci may lay outside of the span depicted.
                Loci with known sequence connections are shown in turquoise 
                and depicted using the physical span of the gene.




# ---------------------------------------------------
# Gene models from a variety of prediction algorithms

[PREDICTION_GENEFINDER]
key          = Prediction: GeneFinder
category     = Genes
feature      = CDS:Genefinder
glyph        = gene
bgcolor      = palevioletred
fgcolor      = palevioletred

[PREDICTION_GENEFINDER:75000]
glyph        = box
strand_arrow = 1
link         = 0

[PREDICTION_GENEMARKHMM]
key          = Prediction: GeneMarkHMM
category     = Genes
feature      = CDS:GeneMarkHMM
glyph        = gene
bgcolor      = palevioletred
fgcolor      = palevioletred
link         = 0
citation     = These are GeneMarkHMM gene predictions provided by Mark Borodovsky. 

[PREDICTION_GENEMARKHMM:75000]   
glyph        = box
strand_arrow = 1
link         = 0

[PREDICTION_JIGSAW]
key          = Prediction: Jigsaw
category     = Genes
feature      = CDS:Jigsaw
glyph        = gene
bgcolor      = palevioletred
fgcolor      = palevioletred
link         = 0
 
[PREDICTION_JIGSAW:75000]   
glyph        = box
strand_arrow = 1
link         = 0

[PREDICTION_MGENE]
key          = Prediction: mGene
category     = Genes
feature      = CDS:mGene
glyph        = gene
bgcolor      = palevioletred
fgcolor      = palevioletred
link         = 0
 
[PREDICTION_MGENE:75000]   
glyph        = box
strand_arrow = 1
link         = 0

[PREDICTION_mSPLICER_TRANSCRIPT]
key          = Prediction: mSplicer
category     = Genes
feature      = CDS:mSplicer_transcript
glyph        = gene
bgcolor      = palevioletred
fgcolor      = palevioletred
link         = 0
citation     = mSplicer predict the splice forms for a given start and
	       end of a transcript. (Note that it is not yet a
               full-featured gene-finder.) There are two versions:
               1. "mSplicer" which splices general pre-mRNA (including
               UTR or coding regions) without assuming the existence of a
               reading frame (requires transcription start and stop).
               2. "mSplicer-ORF" is optimized for coding regions and
               requires the knowledge of the translation start and stop.
               These predictions were generated against regions annotated
               in WS160. More details can be found at <a href="http://www.fml.mpg.de/raetsch/projects/msplicer">http://www.fml.mpg.de/raetsch/projects/msplicer</a>.

[PREDICTION_mSPLICER_TRANSCRIPT:75000]   
glyph        = box
strand_arrow = 1
link         = 0

[PREDICTION_mSPLICER_ORF]
key          = Prediction: mSplicer-ORF
category     = Genes
feature      = CDS:mSplicer_orf
glyph        = gene
bgcolor      = palevioletred
fgcolor      = palevioletred
link         = 0
citation     = mSplicer predict the splice forms for a given start and
	       end of a transcript. (Note that it is not yet a
               full-featured gene-finder.) There are two versions:
               1. "mSplicer" which splices general pre-mRNA (including
               UTR or coding regions) without assuming the existence of a
               reading frame (requires transcription start and stop).
               2. "mSplicer-ORF" is optimized for coding regions and
               requires the knowledge of the translation start and stop.
               These predictions were generated against regions annotated
               in WS160. More details can be found at <a href="http://www.fml.mpg.de/raetsch/projects/msplicer">http://www.fml.mpg.de/raetsch/projects/msplicer</a>.

[PREDICTION_mSPLICER_ORF:75000]
glyph        = box
strand_arrow = 1
link         = 0

[PREDICTION_TWINSCAN]
key          = Prediction: Twinscan
category     = Genes
feature      = CDS:twinscan
glyph        = gene
bgcolor      = palevioletred
fgcolor      = palevioletred
link         = 0
 
[PREDICTION_TWINSCAN:75000]   
glyph        = box
strand_arrow = 1
link         = 0


# ---------------------------------------------------
# Other gene related features: operons, splice sites, etc

[OPERONS]
key          = Operons
category     = Genes
feature      = operon:operon
glyph        = generic
strand_arrow = 1
bgcolor      = green
height       = 10
description  = 1
citation     = These are operons published by Blumenthal et al, Nature 417: 851-854 (2002).

[OPERONS_DEPRECATED]
key          = Operons (deprecated)
category     = Genes
feature      = operon:deprecated_operon
glyph        = generic
strand_arrow = 1
bgcolor      = green
height       = 10
description  = 1
citation     = These are historical operon predictions.


[TRANSPOSONS]
key          = Transposons
category     = Genes
feature      = transposable_element:Transposon
glyph        = segments
bgcolor      = gray
fgcolor      = black
utr_color    = gray
font2color   = blue
height       = 6
title        = Transposon $name
label        = sub { 
 	        my $f = shift;
		my $name = $f->display_name;
		return $name;
	}
# Nothing currently available.
#description  = 0
# No Gene attribute available
#link = sub {
#	my $f = shift;	
#	my $name = $f->attributes('Gene') || $f->name;
#	return "/get?name=$name;class=Gene";
#	}
citation = These are transposon spans reviewed by WormBase curators.

[TRANSPOSONS:150000]
glyph        = generic
strand_arrow = 1
bgcolor      = gray
description  = 0


[TRANSPOSON_GENES]
# EG: CDS:K10E9.2
key          = Transposon Genes
category     = Genes
feature      = transposable_element_CDS:WormBase_transposon transposable_element_Pseudogene:WormBase_transposon
# NOT using the gene glyph since there are no CDS components.
glyph        = transcript
bgcolor      = gray
fgcolor      = black
utr_color    = gray
font2color   = blue
height       = 6
balloon hover  = sub {
                      my $f    = shift;
	              my $name = $f->name;                       
		      my $s    = $f->type;
		      my $type = $s =~ /CDS/ ? 'transposon CDS' : 'transposon pseudogene';
    		      my ($ref,$start,$stop) = ($f->ref,$f->start,$f->stop);
		      my $notes = $f->notes;
		      my $string = join('<br />',"<b>$name</b>",$type,"position: $ref:$start..$stop",
		      	 "notes: $notes");
	 	      return $string;    		      
	       } 
title    = Transposon $name
label    = sub { 
		my $f = shift;
		my $name = $f->display_name;
		return $name;
	}
description  = sub {	     
                      my $f    = shift;
		      my $s    = $f->type;
		      my $type = $s =~ /CDS/ ? 'transposon CDS' : 'transposon pseudogene';
		      return $type;
                }
link = sub {
	my $f = shift;	
	my $name = $f->attributes('Gene') || $f->name;
	return "/get?name=$name;class=Gene";
	}
citation = These are transposon spans reviewed by WormBase curators.

[TRANSPOSON_GENES:150000]
glyph        = generic
strand_arrow = 1
bgcolor      = gray
description  = 0

[POLYA_SITES]
key          = PolyA sites and signal sequences
category     = Genes
feature      = polyA_signal_sequence polyA_site
glyph        = sub {
		my $f = shift;
		return 'diamond' if $f->type =~ /signal/;
		return 'dot' if $f->strand eq '0';
		return 'triangle';
	}
description  = sub { my $s = shift->source; $s=~tr/_/ /; $s; }
point        = 1
orient       = sub {
		my $f = shift;
		return if $f->type =~ /signal/;
		return 'W' if $f->strand eq '-1';
		return 'E';
	}
bgcolor      = purple
link         = sub { my $f   = shift;
                      my $name = $f->name;
   	              return "/get?name=$name;class=Feature";
	}
citation     = High-confidence polyadenylation signal sequences and sites calculated 
	       by an algorithm trained with verified sites from full-length mRNAs. Signals
	       are indicated with a diamond; sites with a triangle.	    

[RNAz]
key          = RNAz non-coding RNA genes
category     = Genes
feature      = ncRNA:RNAz
glyph        = transcript
bgcolor      = white
fgcolor      = black
forwardcolor = violet
reversecolor = cyan
utr_color    = gray
font2color   = blue
label        = sub { 
		my $f = shift;
		my $name = $f->display_name;
		return $name;
	}
description = sub {
	my $f = shift;
	my $notes = join ' ',$f->notes;
	return $notes;
    }
link   = 0
citation     = RNAz-derived ncRNAs were predicted using
        the <a href="http://www.tbi.univie.ac.at/~wash/RNAz/">RNAz algorithm</a>.
        Please select the RNA for more details.

# [TRANS_SPLICED_ACCEPTOR]
#include includes/trans_spliced_acceptor.track





################################################
#
# Category: Variations
#
################################################
[CLASSICAL_ALLELES]
# examples
# I       Allele  insertion_site  3215749 3215748 .       +       .       variation=WBVar00241057;public_name=q271;insertion=g;consequence=Frameshift;interpolated_map_position=-4.47114
#IV      Allele  deletion        13269114        13269407        .       -       .       variation=WBVar00143133;public_name=e345;strain=DR97;consequence=Coding_exon;interpolated_map_position=8.51419
#I       Allele  complex_substitution    8738887 8740543 .       +       .       variation=WBVar00145099;public_name=ef8;strain=EV57;insertion=aataca;consequence=Coding_exon;interpolated_map_position=3.04571
#IV      Allele  substitution    4249906 4249906 .       +       .       variation=WBVar00600724;public_name=m251;strain=DR731;substitution=C/T;consequence=Missense;aachange=A to V;interpolated_map_position=-0.0233166
key          = Classical alleles
category     = Variations
feature      = deletion:Allele
	       insertion_site:Allele
	       substitution:Allele
	       complex_substitution:Allele
label        = sub {
	     my $f = shift;
	     my %attributes = $f->attributes;
	     my $name = $attributes{public_name} || $f->name;
	     if ($name =~ /^WBVar/) {
	         ($name) = $f->attributes('other_name') || $name;
             }	     
	     return join('-',@$name);   
	      }	      
description  = sub {
		my $f = shift;
		my $m = $f->method;
		$m =~ s/_/ /g;
		return $m;
 	}
glyph        = sub {
		my $f = shift;
		my $m = $f->method;
		return 'triangle' if $m eq 'insertion_site';
		return 'triangle' if $m eq 'mobile_element_insertion';
		return 'box'      if $m eq 'complex_substitution';
		return 'box'      if $m eq 'deletion';
		return 'diamond'  if $m eq 'substitution';
		return 'diamond'  if $m eq 'point_mutation';
		return 'generic';
	}
bgcolor      = sub {
		my $f = shift;
		my $m = $f->method;
		return 'red'    if $m eq 'deletion';
		return 'yellow' if $m eq 'point_mutation';
		return 'yellow' if $m eq 'substitution';
		return 'blue'   if $m eq 'complex_substitution';		
		return 'white'; # insertion_site, mobile_element_insertion
	}
fgcolor      = black
font2color   = blue
height       = 8
balloon hover = sub {
	           my $f    = shift;
		   my $type = $f->type;
		   $type =~ s/_/ /g;

		   my ($name)        = $f->attributes('public_name');
		   #$name ||= $f->display_name;
		   my ($consequence) = $f->attributes('consequence');
		   $consequence =~ s/_/ /g;

		   my ($ref,$start,$stop) = ($f->ref,$f->start,$f->stop);
		   my ($status)    = $f->attributes('status');
		   my ($nt_change) = $f->attributes('substitution') || $f->attributes('insertion');
		   my ($aa_change) = $f->attributes('aachange');
		   my ($interpolated_map_position) = $f->attributes('interpolated_map_position');

		   # We might want to be a little fancier with sources, like linking to the resource.
                   my $source = $f->source; 
		   my $sanitized_source = $source;
		   $sanitized_source =~ s/_Polymorphisms//g;
		   $sanitized_source =~ s/_/ /g;

		   my @notes = ("<b>Allele: $name</b>");
		   push (@notes,"type: $type");
		   push (@notes,"status: $status")                  if $status;
		   push (@notes,"position: $ref:$start..$stop");
		   push (@notes,"nucleotide change: $nt_change")     if $nt_change;
		   push (@notes,"amino acid change: $aa_change")     if $aa_change;
           	   push (@notes,"consequence: " . lc($consequence)) if $consequence;
           	   push (@notes,"interpolated map position: $interpolated_map_position")   if $interpolated_map_position;
		   my ($strains) = $f->attributes('strain');
		   if ($strains) {
		      my $strains = join(', ',map { '<a href="http://www.wormbase.org/db/get?class=Strain;name=' . $_ . '">' . $_ . '</a>' } split(',',$strains));
		      push @notes,"strains: $strains"; 
		   }

		   push (@notes,"source: $sanitized_source");  # maybe a link to resource, too?	
		   return join('<br />',@notes);
	}
citation      = This track shows classical alleles comprised of insertions, deletions,
	        substitutions and complex changes. These alleles were typically generated
		during forward genetic screens.
		Red boxes represent deletions; yellow diamonds represent substitutions; 
		blue boxes represent complex substitutions; and white triangles represent
		insertions.



#I       CGH_allele      deletion        3995    4371    .       +       .       Variation "WBVar00601176" ; Public_name "gk3247" ; Strain "VC3124" ; Consequence "Coding_exon"
#I       KO_consortium   complex_substitution    345532  346253  .       +       .       Variation "WBVar00093611" ; Public_name "ok2465" ; Strain "VC1855" ; Consequence "Frameshift"
#I       KO_consortium   deletion        29644   30178   .       +       .       Variation "WBVar00094233" ; Public_name "ok3157" ; Strain "RB2325" ; Consequence "Coding_exon"
#I       KO_consortium   point_mutation  30149   30149   .       +       .       Variation "WBVar00278095" ; Public_name "gk1294" ; Strain "VC1923" ; Substitution "C/T" ; Consequence "Silent"
#I       Million_mutation        point_mutation  4279    4279    .       +       .       Variation "WBVar00604270" ; Public_name "gk859761" ; Strain "VC40875" ; Substitution "A/G" ; Consequence "Missense" ; AAChange "I to T"
#I       Variation_project       deletion        17889   17889   .       +       .       Variation "WBVar01402366" ; Public_name "WBVar01402366" ; Strain "CB4856" ; Polymorphism
#I       Variation_project       insertion_site  91288   91289   .       +       .       Variation "WBVar01359488" ; Public_name "WBVar01359488" ; Strain "CB4856" ; Polymorphism
#III	Variation_project		point_mutation	10702759	10702759	  .		  + .		Variation "WBVar00303351" ; Public_name "otn6530" ; Other_name "OH7116_36658" ; Strain "OH7116" ; Substitution "A/G" ; Consequence "Intron"
#I       NBP_knockout    deletion        14758   15005   .       +       .       Variation "WBVar00252636" ; Public_name "tm4085" ; Consequence "Coding_exon"
# No mobile_element_insertion entries
# X       NemaGENETAG_consortium  transposable_element_insertion_site     17671727        17671728        .       +       .       Variation "WBVar00266444" ; Public_name "ttTi55407" ; Strain "IE55407" ; Consequence "Intron"
[HIGH_THROUGHPUT_ALLELES]
key          = High-throughput alleles
category     = Variations
feature      = deletion:CGH_allele
	       complex_substitution:KO_consortium
	       deletion:KO_consortium
	       point_mutation:KO_consortium
	       deletion:Variation_project
	       insertion_site:Variation_project
	       point_mutation:Variation_project
	       complex_substitution:NBP_knockout
	       deletion:NBP_knockout
	       transposable_element_insertion_site:NemaGENETAG_consortium
label        = sub {
	     my $f = shift;
	     my %attributes = $f->attributes;
	     my $name = $attributes{public_name} || $f->name;
	     if ($name =~ /^WBVar/) {
	         ($name) = $f->attributes('other_name') || $name;
             }	     
	     return join('-',@$name);   
	      }	      
description  = sub {
		my $f = shift;
		my $m = $f->method;
		$m =~ s/_/ /g;
		return $m;
 	}
glyph        = sub {
		my $f = shift;
		my $m = $f->method;
		return 'triangle' if $m eq 'insertion_site';
		return 'triangle' if $m eq 'mobile_element_insertion';
		return 'box'      if $m eq 'complex_substitution';
		return 'box'      if $m eq 'deletion';
		return 'diamond'  if $m eq 'substitution';
		return 'diamond'  if $m eq 'point_mutation';
		return 'generic';
	}
bgcolor      = sub {
		my $f = shift;
		my $m = $f->method;
		return 'red'    if $m eq 'deletion';
		return 'yellow' if $m eq 'point_mutation';
		return 'yellow' if $m eq 'substitution';
		return 'blue'   if $m eq 'complex_substitution';		
		return 'white'; # insertion_site, mobile_element_insertion
	}
fgcolor      = black
font2color   = blue
height       = 8
balloon hover = sub {
	           my $f    = shift;
		   my $type = $f->method;
		   $type =~ s/_/ /g;

		   my ($name)        = $f->attributes('public_name');
		   #$name ||= $f->display_name;
		   my ($consequence) = $f->attributes('consequence');
		   $consequence =~ s/_/ /g;

		   my ($ref,$start,$stop) = ($f->ref,$f->start,$f->stop);
		   my ($status)    = $f->attributes('status');
		   my ($nt_change) = $f->attributes('substitution') || $f->attributes('insertion');
		   my ($aa_change) = $f->attributes('aachange');
		   my ($interpolated_map_position) = $f->attributes('interpolated_map_position');

		   # We might want to be a little fancier with sources, like linking to the resource.
                   my $source = $f->source; 
		   my $sanitized_source = $source;
		   $sanitized_source =~ s/_Polymorphisms//g;
		   $sanitized_source =~ s/_/ /g;

		   my @notes = ("<b>Allele: $name</b>");
		   push (@notes,"type: $type");
		   push (@notes,"status: $status")                  if $status;
		   push (@notes,"position: $ref:$start..$stop");
		   push (@notes,"nucleotide change: $nt_change")     if $nt_change;
		   push (@notes,"amino acid change: $aa_change")     if $aa_change;
           	   push (@notes,"consequence: " . lc($consequence)) if $consequence;
           	   push (@notes,"interpolated map position: $interpolated_map_position")   if $interpolated_map_position;
		   my ($strains) = $f->attributes('strain');
		   if ($strains) {
		      my $strains = join(', ',map { '<a href="http://www.wormbase.org/db/get?class=Strain;name=' . $_ . '">' . $_ . '</a>' } split(',',$strains));
		      push @notes,"strains: $strains"; 
		   }

		   push (@notes,"source: $sanitized_source");  # maybe a link to resource, too?	
		   return join('<br />',@notes);
	}
citation      = These are alleles generated through high-throughput, genome-wide projects. Million Mutation Project alleles are placed in a separate track.

[POLYMORPHISMS]
# Polymorphism was MISSPELLED IN WS240. Update to correct spelling for WS241.
key          = Polymorphisms
category     = Variations
feature      = deletion:CGH_allele_Polymorhpism
           substitution:Variation_project_Polymorhpism
               deletion:Variation_project_Polymorhpism
                    SNP:Variation_project_Polymorhpism
#         insertion_site:Variation_project_Polymorhpism
#   complex_substitution:Variation_project_Polymorhpism
#   sequence_alteration:Variation_project_Polymorhpism
label        = sub {
	     my $f = shift;
	     my %attributes = $f->attributes;
	     my $name = $attributes{public_name} || $f->name;
	     if ($name =~ /^WBVar/) {
	         ($name) = $attributes{other_name} || $name;
             }	     
	     return join('-',@$name);   
	      }	      
description  = sub {
		my $f = shift;
		my $m = $f->method;
		$m =~ s/_/ /g;
		return $m;
 	}
glyph        = sub {
		my $f = shift;
		my $m = $f->method;
		return 'triangle' if $m eq 'insertion_site';
		return 'triangle' if $m eq 'mobile_element_insertion';
		return 'box'      if $m eq 'complex_substitution';
		return 'box'      if $m eq 'deletion';
		return 'diamond'  if $m eq 'substitution';
		return 'diamond'  if $m eq 'point_mutation';
		return 'generic';
	}
fgcolor      = black
font2color   = blue
balloon hover = sub {
	           my $f    = shift;
		   my $type = $f->method;
		   $type =~ s/_/ /g;

		   my ($name)        = $f->attributes('public_name');
		   #$name ||= $f->display_name;
		   my ($consequence) = $f->attributes('consequence');
		   $consequence =~ s/_/ /g;

		   my ($ref,$start,$stop) = ($f->ref,$f->start,$f->stop);
		   my ($status)    = $f->attributes('status');
		   my ($nt_change) = $f->attributes('substitution') || $f->attributes('insertion');
		   my ($aa_change) = $f->attributes('aachange');
		   my ($interpolated_map_position) = $f->attributes('interpolated_map_position');

		   # We might want to be a little fancier with sources, like linking to the resource.
                   my $source = $f->source; 
		   my $sanitized_source = $source;
		   $sanitized_source =~ s/_Polymorphisms//g;
		   $sanitized_source =~ s/_/ /g;

		   my @notes = ("<b>Allele: $name</b>");
		   push (@notes,"type: $type");
		   push (@notes,"status: $status")                  if $status;
		   push (@notes,"position: $ref:$start..$stop");
		   push (@notes,"nucleotide change: $nt_change")     if $nt_change;
		   push (@notes,"amino acid change: $aa_change")     if $aa_change;
           	   push (@notes,"consequence: " . lc($consequence)) if $consequence;
           	   push (@notes,"interpolated map position: $interpolated_map_position")   if $interpolated_map_position;
		   my ($strains) = $f->attributes('strain');
		   if ($strains) {
		      my $strains = join(', ',map { '<a href="http://www.wormbase.org/db/get?class=Strain;name=' . $_ . '">' . $_ . '</a>' } split(',',$strains));
		      push @notes,"strains: $strains"; 
		   }

		   push (@notes,"source: $sanitized_source");  # maybe a link to resource, too?	
		   return join('<br />',@notes);
	}
bgcolor      = sub {
		my $f = shift;	
		my %attributes = $f->attributes();
		if ($f->attributes('strain') eq 'CB4858') {
		    return 'blue';
		} elsif ($f->attributes('strain') eq 'CB4856') {
		    return 'yellow';
                } else {
		    return 'white';
                } 
	}
height       = sub {
	        my $f = shift;
		my %attributes = $f->attributes();

                # Confirmed, RFLP SNPs
                if (defined $attributes{rflp} && $attributes{status} eq 'Confirmed') {
                        return 14;
                } else {
                        return 8;
                }
        }	
citation     = This track shows single nucleotide polymorphisms (SNPs).
               In this track, the molecular nature of the polymorphism is indicated by
               its glyph: Boxes are deletions; triangles are insertions; point mutations
               and substitutions are diamonds. Color reflects the source strain: blue
	       polymorphisms were identified in CB4858 (Pasadena), yellow in CB4856
	       (Hawaii), all other backgrounds are white.









#################################################################################################
#
#    END VARIATION TRACKS
#
#################################################################################################

